# 백준 [테트로미노]
# 구현, 브루트포스

n, m = map(int, input().split())
board = [list(map(int, input().split())) for _ in range(n)]

# n, m = 5, 5
# board = [[1, 2, 3, 4, 5], [5, 4, 3, 2, 1], [2, 3, 4, 5, 6], [6, 5, 4, 3, 2], [1, 2, 1, 2, 1]]
answer = 0

# 테트로미노 19가지 모양 리스트와 튜플로 정의
tetromino = [
    [(0,0), (0,1), (1,0), (1,1)], # ㅁ
    [(0,0), (0,1), (0,2), (0,3)], # ㅡ
    [(0,0), (1,0), (2,0), (3,0)], # ㅣ
    [(0,0), (0,1), (0,2), (1,0)], 
    [(1,0), (1,1), (1,2), (0,2)],
    [(0,0), (1,0), (1,1), (1,2)], # ㄴ
    [(0,0), (0,1), (0,2), (1,2)], # ㄱ
    [(0,0), (1,0), (2,0), (2,1)],
    [(2,0), (2,1), (1,1), (0,1)],
    [(0,0), (0,1), (1,0), (2,0)], 
    [(0,0), (0,1), (1,1), (2,1)],
    [(0,0), (0,1), (0,2), (1,1)], # ㅜ
    [(1,0), (1,1), (1,2), (0,1)], # ㅗ
    [(0,0), (1,0), (2,0), (1,1)], # ㅏ
    [(1,0), (0,1), (1,1), (2,1)], # ㅓ
    [(1,0), (2,0), (0,1), (1,1)],
    [(0,0), (1,0), (1,1), (2,1)],
    [(1,0), (0,1), (1,1), (0,2)],
    [(0,0), (0,1), (1,1), (1,2)]
]

# find 함수
def find(x, y):
    global answer
    # 테트로미노 19가지 모양
    for i in range(19):
        # 각 테트로미노의 합산 값을 더함
        result = 0
        # 테트로미노 4개 블럭
        for j in range(4):
            # try ~ except문 이용하여 board 안에 있는 경우와 밖에 있는 경우 처리
            try: 
                # 현재 위치에서 테트로미노를 놓은 x 좌표
                nx = x + tetromino[i][j][0]
                # 현재 위치에서 테트로미노를 놓은 y 좌표
                ny = y + tetromino[i][j][1]
                # 합산 값
                result += board[nx][ny]
            # except index error 경우
            except IndexError:
                continue

        # 최대 값과 result 비교 후 저장
        answer = max(answer, result)     

# solve 함수
def solve():
    # 모든 board의 위치를 탐색하면서 find() 함수 호출 해보기
    for i in range(n):
        for j in range(m):
            find(i, j)


solve()
print(answer)